<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Overlay Ruleta TikTok (TikFinity WS)</title>
  <style>
    :root {
      --bg: rgba(0,0,0,.25);
      --pill: rgba(0,0,0,.55);
      --accent: #ffd54f;
      --dur: 15000ms;
    }
    html,body { height:100%; }
    body {
      margin:0; font-family: system-ui, Segoe UI, Roboto, Arial;
      background: var(--bg); color:#fff; overflow:hidden;
    }
    #topbar {
      position: absolute; inset: 12px 12px auto 12px;
      display:flex; gap:10px; align-items:center; z-index: 100;
    }
    .pill { padding:8px 12px; border-radius:12px; background:var(--pill); backdrop-filter:blur(6px); font-weight:600; }
    #status.ok { background: rgba(0,120,60,.6); }
    #status.err { background: rgba(140,0,0,.6); }
    #wrap { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    #viewport {
      width:900px; max-width:95vw; height:180px; border-radius:16px; position:relative; overflow:hidden;
      background:rgba(20,20,20,.55); outline:2px solid rgba(255,255,255,.08); box-shadow:0 8px 24px rgba(0,0,0,.35);
    }
    #carril { display:flex; gap:12px; padding:0 24px; transform:translateX(0); }
    #carril.anim { transition: transform var(--dur) cubic-bezier(.12,.65,.22,1); }
    .item {
      display:inline-flex; align-items:center; justify-content:center; padding:12px 16px;
      aspect-ratio:1/1; min-width:110px; height:auto; border-radius:12px;
      font-size:20px; font-weight:800; text-align:center; border:1px solid rgba(255,255,255,.12); user-select:none; line-height:1.1;
    }
    .item.nada { background:rgba(207,25,25,.7); }
    .item.casi { background:rgba(224,219,56,.7); color:#000; }
    .item.win  { background:rgba(16,203,66,.75); }
    #marker { position:absolute; inset:0; pointer-events:none; z-index:5; }
    #marker::after {
      content:""; position:absolute; top:-6px; left:50%; transform:translateX(-50%);
      border-left:12px solid transparent; border-right:12px solid transparent; border-top:16px solid var(--accent);
      filter:drop-shadow(0 2px 4px rgba(0,0,0,.4));
    }
    #toast {
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%) translateY(50px);
      background:rgba(0,0,0,.75); padding:10px 16px; border-radius:10px; opacity:0;
      transition:transform .35s ease, opacity .35s ease; font-weight:700;
    }
    #toast.show { opacity:1; transform:translateX(-50%) translateY(0); }
    #gifterBadge {
      position:absolute; left:50%;
      top:calc(50% - 180px/2 - 24px); transform:translateX(-50%);
      background:rgba(0,0,0,.8); padding:6px 12px; border-radius:10px; font-weight:800; font-size:14px; white-space:nowrap;
      opacity:0; transition:opacity .3s ease, transform .3s ease; pointer-events:none; z-index:20;
    }
    #gifterBadge.show { opacity:1; transform:translateX(-50%) translateY(-4px); }
    #btn { pointer-events:auto; }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="status" class="pill">WS: conectando…</div>
    <button id="btn" class="pill">Girar (prueba)</button>
  </div>

  <div id="wrap">
    <div id="gifterBadge"></div>

    <div id="viewport">
      <div id="marker"></div>
      <div id="carril">
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item casi">Casi</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item casi">Casi</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item casi">Casi</div>
        <div class="item nada">Nada</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item casi">Casi</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
        <div class="item nada">Nada</div>
      </div>
    </div>

    <div id="toast">Premio: —</div>
  </div>

<script>
  // ===== CONFIG =====
  const PROBABILIDADES = { nada: 1.0, casi: 0, win: 0 }; // Ajusta a tu gusto
  const BASE_MS = 15000, MS_POR_SLOT = 0, COPIAS = 15;
  const CENTER_NUDGE_PX = 0;

  const COINS_PER_SPIN = 30;   // 30 monedas = 1 giro
  const COUNT_PER_SPIN = 0;    // alternativa si quieres contar por "count"
  const ONLY_ON_STREAK_END = true; // contar solo al finalizar racha (evita giros dobles)

  // Variantes de rosquilla (mapeo por nombre -> monedas)
  const GIFT_VALUES = {
    "rosquilla": 30, "rosquillas": 30,
    "dona": 30, "donas": 30,
    "donut": 30, "donuts": 30
  };

  // ===== Estado =====
  let ws = null, spinning = false;
  let pendingSpins = 0;
  let spinQueue = [];
  const statusEl = document.getElementById('status');
  const btn = document.getElementById('btn');
  const viewport = document.getElementById('viewport');
  const carril = document.getElementById('carril');
  const toast = document.getElementById('toast');
  const gifterBadge = document.getElementById('gifterBadge');
  let baseCount = 0, middleBlock = 0, currentAbs = 0, ITEM_W = 150, STEP_W = 162;
  let hideBadgeTimer = null;
  let CURRENT_TX = 0;

  // ===== Layout =====
  function measureSizes(){
    const prev = carril.style.transform;
    carril.classList.remove('anim'); carril.style.transform = 'translateX(0px)';
    const items = carril.querySelectorAll('.item');
    if(items.length >= 2){
      const r1 = items[0].getBoundingClientRect();
      const r2 = items[1].getBoundingClientRect();
      ITEM_W = r1.width; STEP_W = r2.left - r1.left;
    }
    requestAnimationFrame(()=>{ carril.style.transform = prev || 'translateX(0px)'; });
  }
  function setTransform(tx, smooth=false, durMs=BASE_MS){
    if(smooth){ carril.style.setProperty('--dur', `${Math.max(50, Math.round(durMs))}ms`); carril.classList.add('anim'); }
    else { carril.classList.remove('anim'); }
    CURRENT_TX = tx;
    carril.style.transform = `translateX(${tx}px)`;
  }
  function renderTo(absIndex, smooth=true, durMs=BASE_MS){
    const rect = viewport.getBoundingClientRect();
    const center = (rect.width/2) - (ITEM_W/2);
    const tx = -(absIndex * STEP_W) + center;
    setTransform(tx, smooth, durMs);
    currentAbs = absIndex;
  }
  function mod(n,m){ return ((n % m) + m) % m; }
  function recenter(absIndex){ const rel = mod(absIndex, baseCount); renderTo(middleBlock*baseCount + rel, false); }

  // ===== Probabilidades =====
  function getWeightedRandomIndex() {
    const items = carril.querySelectorAll('.item');
    const buckets = { nada: [], casi: [], win: [] };
    for (let i = 0; i < baseCount; i++) {
      const cls = items[i].classList;
      const tipo = cls.contains('win') ? 'win' : (cls.contains('casi') ? 'casi' : 'nada');
      buckets[tipo].push(i);
    }
    const ORDER = ['nada','casi','win'];
    const weights = {}; let sum = 0;
    for (const k of ORDER) {
      let w = Math.max(0, Number(PROBABILIDADES[k] ?? 0));
      if (!buckets[k].length) w = 0;
      weights[k] = w; sum += w;
    }
    if (sum <= 0) {
      for (const k of ORDER) if (buckets[k].length) {
        const b = buckets[k]; return b[Math.floor(Math.random()*b.length)];
      }
      return 0;
    }
    const r = Math.random(); let acc = 0;
    for (const k of ORDER) {
      acc += weights[k]/sum;
      if (r < acc && buckets[k].length) {
        const b = buckets[k]; return b[Math.floor(Math.random()*b.length)];
      }
    }
    for (let i=ORDER.length-1;i>=0;i--){ const b=buckets[ORDER[i]]; if (b.length) return b[Math.floor(Math.random()*b.length)]; }
    return 0;
  }

  // ===== UI =====
  function showToast(txt,ms=1200){ toast.textContent = txt; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), ms); }
  function showBadge(txt){ if(hideBadgeTimer) clearTimeout(hideBadgeTimer); gifterBadge.textContent = `🎁 ${txt}`; gifterBadge.classList.add('show'); }
  function hideBadgeLater(ms=800){ if(hideBadgeTimer) clearTimeout(hideBadgeTimer); hideBadgeTimer = setTimeout(()=>gifterBadge.classList.remove('show'), ms); }
  function getItemUnderMarker(){
    const rect = viewport.getBoundingClientRect();
    const x = rect.left + rect.width/2 + CENTER_NUDGE_PX;
    const y = rect.top + 8;
    let el = document.elementFromPoint(x, y);
    while (el && !el.classList?.contains('item')) el = el.parentElement;
    return el || null;
  }
  function snapCenterOnElement(el){
    if(!el) return;
    const vp = viewport.getBoundingClientRect();
    const er = el.getBoundingClientRect();
    const delta = (er.left + er.width/2) - (vp.left + vp.width/2);
    setTransform(CURRENT_TX - delta, false);
  }

  // ===== Normalización =====
  function normalizeGiftKey(name){
    if(!name) return "";
    const k = String(name).toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    if (/\brosquill/.test(k)) return 'rosquilla';
    if (/\bdona/.test(k))     return 'dona';
    if (/\bdonut/.test(k))    return 'donut';
    return k;
  }
  function inferCoinsFromName(name, count=1) {
    const key = normalizeGiftKey(name);
    const variants = [key, key.endsWith('s') ? key.slice(0,-1) : key+'s'];
    for (const v of variants){ if (GIFT_VALUES[v] != null) return GIFT_VALUES[v] * Math.max(1, count); }
    return 0;
  }

  // ===== DEDUPE (anti-duplicados) =====
  const DEDUPE_TTL_MS = 3000;
  const dedupeCache = new Map();
  function makeGiftKey(data) {
    const uid = data.uniqueId || data.userId || data.user || 'anon';
    const giftId = data.giftId || data.gift?.id || data.giftName || data.gift || 'gift';
    const rep = Number(data.repeatCount ?? data.count ?? 1) || 1;
    const diamonds = Number(data.diamondCount ?? data.diamonds ?? data.value ?? 0) || 0;
    const end = String(Boolean(data.repeatEnd ?? data.streakEnd ?? data.comboEnd ?? data.isCompleted));
    const msgId = data.messageId || data.id || '';
    return `${msgId}|${uid}|${giftId}|${rep}|${diamonds}|end:${end}`;
  }
  function isDuplicateGift(data){
    const key = makeGiftKey(data);
    const now = Date.now();
    for (const [k, t] of dedupeCache) if (now - t > DEDUPE_TTL_MS) dedupeCache.delete(k);
    const last = dedupeCache.get(key);
    if (last && (now - last) < DEDUPE_TTL_MS) return true;
    dedupeCache.set(key, now);
    return false;
  }

  // ===== Conteo de giros desde datos TikFinity =====
  function parseCoinsFromObj(obj){
    const fields = ['coins','coin','value','diamonds','diamond','giftCoins','gift_coins','giftValue','gift_value','diamondCount'];
    for (const f of fields){
      const v = Number(obj?.[f]);
      if (Number.isFinite(v) && v > 0) return v;
    }
    return NaN;
  }

  function spinsFromGiftData(data){
    const giftName = data.giftName ?? data.gift ?? data.name ?? '';
    const username = data.uniqueId ?? data.nickname ?? data.user ?? data.username ?? 'Anónimo';
    const count = Number(data.repeatCount ?? data.count ?? data.quantity ?? data.comboCount ?? data.combo_count ?? 1) || 1;

    const hasFlags = ('repeatEnd' in data) || ('streakEnd' in data) || ('comboEnd' in data) || ('isCompleted' in data);
    const isEnd = Boolean(data.repeatEnd ?? data.streakEnd ?? data.comboEnd ?? data.isCompleted ?? false);

    // anti-duplicados
    if (isDuplicateGift(data)) return {spins:0, user:username, giftName};

    // si pediste contar solo al final de racha y hay flags pero aún no termina, no contar
    if (ONLY_ON_STREAK_END && hasFlags && !isEnd) return {spins:0, user:username, giftName};

    // monedas directas
    const coinsDirect =
      parseCoinsFromObj(data) ||
      parseCoinsFromObj(data.gift) ||
      NaN;
    if (Number.isFinite(coinsDirect) && coinsDirect > 0){
      return {spins: Math.max(0, Math.floor(coinsDirect / COINS_PER_SPIN)), user: username, giftName};
    }

    // inferencia por nombre * cantidad (rosquillas)
    const inferred = inferCoinsFromName(giftName, Math.max(1, count));
    if (inferred > 0){
      return {spins: Math.max(0, Math.floor(inferred / COINS_PER_SPIN)), user: username, giftName};
    }

    // último recurso: por conteo si lo activas
    if (COUNT_PER_SPIN > 0 && count > 0){
      return {spins: count * COUNT_PER_SPIN, user: username, giftName};
    }

    return {spins:0, user:username, giftName};
  }

  // ===== Giro =====
  function spinOnce(){
    if(spinning) return;
    spinning = true;
    const currentSpinner = spinQueue.shift() || 'Anónimo';
    pendingSpins = Math.max(0, pendingSpins - 1);
    showBadge(currentSpinner);

    const idxRel = getWeightedRandomIndex();
    const vueltas = 2 + Math.floor(Math.random()*2);
    const pasos = vueltas*baseCount + idxRel;
    const durMs = BASE_MS + pasos*MS_POR_SLOT;
    const targetAbs = currentAbs + pasos;

    renderTo(targetAbs, true, durMs);

    const onEnd = () => {
      recenter(targetAbs);
      const elCentro = getItemUnderMarker();
      snapCenterOnElement(elCentro);
      const premio = elCentro ? elCentro.innerText.trim().replace(/\s+/g,' ') : '(?)';
      showToast('Premio: ' + premio);
      hideBadgeLater(600);
      spinning = false;
      if (pendingSpins > 0) setTimeout(spinOnce, 300);
    };
    carril.addEventListener('transitionend', onEnd, {once:true});
  }

  function queueSpins(n, user){
    n = Math.max(0, Math.floor(n||0));
    if (!n) return;
    const name = user || 'Anónimo';
    for (let i=0;i<n;i++) spinQueue.push(name);
    pendingSpins += n;
    console.log(`[QUEUE] +${n} giros por ${name}. Pendientes: ${pendingSpins}`);
    if (!spinning) spinOnce();
  }

  // ===== Init =====
  (function init(){
    const baseHTML = carril.innerHTML;
    baseCount = carril.children.length;
    for(let i=1;i<COPIAS;i++) carril.insertAdjacentHTML('beforeend', baseHTML);
    middleBlock = Math.floor(COPIAS/2);
    measureSizes();
    currentAbs = middleBlock*baseCount + Math.floor(baseCount/2);
    renderTo(currentAbs, false);
    window.addEventListener('resize', ()=>{ measureSizes(); renderTo(currentAbs, false); });
  })();

  btn.addEventListener('click', () => { if (!spinning && pendingSpins===0) queueSpins(1, 'Tester'); });

  // Tecla T = simular 15 rosquillas -> 450 monedas -> 15 giros con COINS_PER_SPIN=30
  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='t'){
      const sim = { event:'gift', data:{ giftName:'Rosquillas', repeatCount:15, diamondCount: 450, repeatEnd:true } };
      const {spins,user,giftName} = spinsFromGiftData(sim.data);
      console.log(`[SIM] ${giftName || '(sin nombre)'} -> spins: ${spins}`);
      if (spins > 0) queueSpins(spins, user || 'Tester');
      else showToast('Simulación sin giros', 1200);
    }
  });

  // ===== WebSocket TikFinity =====
  function getWSUrl(){
    const u = new URL(window.location.href);
    return u.searchParams.get('ws') || 'ws://192.168.1.69:21213/';
  }

  function openWS(){
    const url = getWSUrl();
    console.log('[WS] conectando a', url);
    try{ ws = new WebSocket(url); }
    catch(e){ statusEl.textContent='WS: error URL'; statusEl.classList.add('err'); return; }

    ws.onopen = () => {
      statusEl.textContent='WS: conectado';
      statusEl.classList.add('ok'); statusEl.classList.remove('err');
    };
    ws.onclose = () => {
      statusEl.textContent='WS: desconectado';
      statusEl.classList.remove('ok');
      setTimeout(openWS, 1000);
    };
    ws.onerror = (e) => {
      console.warn('[WS] error', e);
      statusEl.textContent='WS: error'; statusEl.classList.add('err');
    };

    ws.onmessage = (ev) => {
      let raw = ev.data;
      try{
        const msg = JSON.parse(raw);
        const evt = msg.event;
        const data = msg.data || {};
        if (evt === 'gift'){
          const {spins, user, giftName} = spinsFromGiftData(data);
          console.log(`[WS] gift ${giftName || '(sin nombre)'} -> spins: ${spins}`);
          if (spins > 0) queueSpins(spins, user);
        }
      }catch(err){
        console.warn('[WS] no-JSON o formato inesperado:', raw, err);
      }
    };
  }
  openWS();
</script>
</body>
</html>
